#+TITLE: Awk
#+DATE: [2022-01-04 Tue 20:32]
* Awk
** 关于 printf 命令的运用
awk 对于输出的美化是使用 printf 命令，可以说是比较方便的，但是他本身没有换行，所以你需要自己添加换行
#+begin_src shell
cd ~/Shell/Awk
awk '$3 > 0 { printf("You should pay %s for $%6.2f\n", $1, $2 * $3) }' emp.data
#+end_src

#+RESULTS:
| You | should | pay | Kathy | for | $       | 40.0 |
| You | should | pay | Mark  | for | $100.00 |      |
| You | should | pay | Mary  | for | $121.00 |      |
| You | should | pay | Susie | for | $       | 76.5 |
** awk 中的逻辑运算符
| ~&&~       | and |
|------------+-----|
| \Vert\Vert | or  |
| ~!~        | not |
** 数据验证
#+begin_src shell
cd ~/Shell/Awk
awk 'NF!=3 {print $0, "number of filed is not equal to 3"}
	$2 < 2.35 {print $0 "rate is below minimum wage"}
	$2 > 10 {print $- "rate exceeds $10 per hour"}' emp.data
#+end_src

#+RESULTS:
** 字符串比较
和大部分编程语言一样，字符串比较大小都是比较 ASCII 码，比较先后顺序，先出现就是先出现。
** 字符串匹配模式
Awk 中的正则和 shell 的正则没有太大的区别
** 添加新的 field
~$5 = $2 / $1~ =$5= 不存在，自己构建，如果字段变量引用到了不存在的数值，那么就是空字符串
** 数值计算
awk 中所有的算数运算都是浮点数， ~^~ 是指数运算， ~/~ 是除法运算， ~%~ 是模运算，其余的没有其他的区别
** 条件运算
awk 中也有类似C语言的条件表达式
~expr1?expr2:expr3~ 如果 ~expr1~ 为真，返回 ~expr2~ ，否则就是 ~expr3~
** 分割
不同的语句之间使用的 ~;~ 作为分割
** 自增和自减
~++~ 自增和 ~--~ 自减在 awk 中是可以的，类似的组合运算符号 ~+= and -= /=~
** 内建算术函数
比较常见的都是
- ~rand()~ 返回一个 0 到 1 之间的随机数
- ~srand(x)~ 设置随机数种子
- ~atan2(y, x)~ 返回 ~y/x~ 的反正切值
  这个倒是用的少
- ~int(x)~ 返回 x 的整数部分
- ~sin(x)~
- ~cos(x)~
- ~log(x)~
- ~exp(x)~
- ~sqrt(x)~
** 字符串运算符号
Awk 中只有 =拼接= 这一种字符串运算，其实就是写一起
** 用作正则表达式的字符串
在一个匹配表达式中，一个被双引号包围的字符串，可以与一个被斜杠包围的正则表达式一起使用，但当被双引号的字符串想要匹配一个 =元字符= 的字面值，
则需要在反斜杠前面在加一个反斜杠，如下：
~/(\+|-)[0-9]+/~ 匹配正负数，如果使用双引号包裹，则为 ~"(\\+|-)[0-9]+"~ ，需要添加 一个 ~\~ 来保护 ~\~
** 内建字符串函数
| function          | 描述                                                         |
|-------------------+--------------------------------------------------------------|
| ~grub(r, s)~      | 将 =$0= 中所有的 r 替换为 s, 返回替换的次数                  |
| ~grub(r, s, t)~   | 将字符串 t 中的所有的 r 替换为 s, 返回替换的次数             |
| ~index(s, t)~     | 返回字符串 t 在 s 中第一次出现的位置，如果没有，那么返回 0   |
| ~length(s)~       | 返回 s 包含的字符个数                                        |
| ~match(s, r)~     | 测试 s 中是否包含有被 r 匹配的字符串，返回子串起始位置或者 0 |
| ~split(s, a)~     | 已内建变量 =FS= 分割 s 到数组 a ，返回字段的个数             |
| ~split(s, a, fs)~ | 以 fs 分割 s 到数组 a ，返回字段的个数                       |
| ~sprintf()~       | 和 printf 一样，只不过不打印，返回结果                       |
| ~sub(r, s)~       | 将 ~$0~ 中最左最长（贪婪匹配）的能被 r 匹配的字符串替换为 s         |
| ~sub(r, s, t)~    |                                                              |
| ~substr(s, p)~    | 返回 s 中从位置 p 开始的后缀                                 |
| ~substr(s, p n)~  | 返回 s 中从位置 p 开始的后缀，长度为 n                           |
** 数值或者字符串
当 awk 在运行状态下创建一个字段的时候，会自动把他的类型设置为字符串；另外，如果字段包含一个机器可以识别的数，他也会给这个字段设置一个数值类型
1. 未初始化的变量默认初始值为 0 或者空字符串。不存在或者显式为空的字段有字段之 ~""~ ，他们不是数值，但当强制转换的时候，将会是 0 （感觉这个和 js 语句差不多啊）
   1. 将数字转化为字符串 ~number ""~ （使用了字符串拼接）
   2. 将字符串转化为数字 ~string + 0~ （数字加法）字符串是指 ~"1e10"~
2. =OFMT= 数值的输出格式，默认为 ~%.6g~
3. *由于没有显式的拼接，所以涉及其他的运算的时候，使用 () 进行包裹*
   1. ~$1 < 0 { print "abs($1) = " -$1}~ ，用 ~$1 < 0 { print "abs($1) = " (-$1)}~ 
** 流程控制语句
if, switch, while, for 和C语言基本类似，甚至还有 ~do while~
** 数组
1. Awk 提供了一维数组，没有多维数组。Awk 的数组与大多数其他语言不同的点是，awk 数组元素下标是字符串，因此，awk 的数组也称为 *关联数组* 
判断下标 =subscript= 是否在数组 =pop= 中，使用命令如下
#+begin_src awk
if("subscript" in pop){
	
}
#+end_src
这个命令不会在数组 pop 中产生新的索引，但是使用如下命令，则会产生新的索引
#+begin_src awk
if(pop["subscript"] != ""){
	
}
#+end_src
2. 使用命令 ~delete~ 可以删除数组中的元素
*** 多维数组
Awk 中不直接支持多维数组，可以手动模拟一下，形如 ~array[i, j]~ 但是在内部形式上 不是 ~i, j~ ，而是通过内建变量 =SUBSEP= 来分割，
最终形式为 ~i SUBSEP j~ =SUBSEP= 一般是 =\034= 对应的 ASCII 码的八进制。 *数组的元素不能再是数组*
** 函数
awk 中的函数和 shell 一样，调用函数的时候，函数名和左括号之间不能有空格。
一般来说，函数接收的变量是变量值的一份拷贝，所以函数操作的是变量的拷贝，而不是变量本身。这意味者函数不会对函数体外部的变量的值产生影响，（标量，按照数值传递）
但当数组作为参数的时候，函数接受到的参数不是数组的拷贝，所以函数可以改变数组的元素（引用传递），函数名不能作为参数使用（不是一等函数）
- 在 awk 中，函数体只有参数是局部变量，只有函数执行的时候才有效，与程序中其他同名变量没有一丝的关联，函数体中其他的变量都是全局变量
- 意味者，如果你需要私有的局部变量，只有放在参数列表中（初始值为空）。
