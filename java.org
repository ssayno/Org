#+BLOG: myblog
#+POSTID: 134
#+DATE: [2022-04-13 Wed 16:23]
#+TITLE: Java
#+startup: overview
* Java 中的主方法
~public static void main(String []args){}~
1. ~public~ 公共方法
2. ~static~ 设置为类直接调用方法，使得未实例化类就可以直接调用该方法。
3. ~void~ 主方法是一切的起点，开始无返回。
4. ~main~ 系统定义的方法名称。
5. ~String[] args~ 命令行参数。
* Object 类
Object 类主要特点是可以解决参数的统一问题，使用 Object 类可以接收所有的数据类型。
** 简介
Java 中只有一个类没有继承关系，就是 Object 类，所有类都是 Object 的子类。考虑到所有的继承问题，所以该类提供有无参构造方法， 这样在类定义的时候，不会出现构造方法调用失败的原因。
** 获取对象的信息
~toString()~ 方法，定义类的时候，推荐直接进行覆写。
** 对象比较
~equals()~ 对象比较的处理，还是推荐覆写。
默认的 ~equals()~ 方法
#+begin_src java
public boolean equals(Object obj){
    return (this == obj);
}
#+end_src
只是进行了地址比较，如果我们要进行正确的判断，我们需要在子类中覆写该方法，一般来说，IDE 会提供这个操作。
#+begin_src java
@Override
public boolean equals(Object o) {
    // 判断是不是本身
    if (this == o) return true;
    // 判断是否是 NULL 以及是否 是同一个 class
    if (o == null || getClass() != o.getClass()) return false;
    // 向下转型
    Student student = (Student) o;
    // 进行内容的判断，根据自己的 属性进行书写。
    return math == student.math && English == student.English;
}
#+end_src
覆写 ~equals()~ 的三大注意点
1. 是否是同一个对象（同一个地址） ~if(this == o)~
2. 传入是否为空
3. 以及是否是同一个 ~class~ ~if(o==null && !(o instanceof Person))~ 或者 ~if(o=null &&this.getClass() != o.getClass())~ （推荐后面这种，简单）
* Stream
数据流: 就是字节数据（二进制数据），java 中有两个包进行操作
1. 字节处理流： ~OutputStream~ 和 ~InputStream~
2. 字符处理流： ~Write(输出字符流)~ 和 ~Reader(输入字符流)~
3. 输入 ~Reader~ 和 ~InputStream~ ，同理就是输出
** 流操作的同一步骤
1. 如果是文件的操作，则要通过一个 =File= 类找到一个文件
2. 通过字节流或字符流的子类进行父类实例化(上面提到的都是抽象类)
3. 利用字节流或者字符流进行数据的输入和输出
4. 流的操作是资源操作，需要进行关闭
*** OutputStream
#+begin_src java
public abstract class OutputStream extends Object implements Closeable, Flushable
#+end_src
接口 ~Closeable~ 提供 ~close()~, 接口 ~Flushable~ 提供 ~flush()~, ~OutputStream~ 自己也定义了
**** 方法
| No | Name                                                           | Type   | Description      |
|----+----------------------------------------------------------------+--------+------------------|
|  1 | public void write(byte[] b) throws IOException                 | 普通   | 输出一组字节数据 |
|  2 | public abstract void write(int b) throws IOException           | *重要* | 输出单个字节数据 |
|  3 | public void write(byte[] b,int off,int len) throws IOException | 普通   | 输出部分字节数据 |
**** 子类
1. ~FileOutputStream~
   使用文件 ~File~ 类进行构造
    #+begin_verse
    构造方法
    1. 覆盖 FileOutputStream(File file)
    2. 追加 FileOutputStream(File file, boolean append)
    #+end_verse
*** InputStream
#+begin_src java
public abstract class InputStream extends Object implements Closeable
#+end_src
**** 方法
| No | Name                                                           | Type   | Description                    |
|----+----------------------------------------------------------------+--------+--------------------------------|
|  1 | public abstract int read() throws IOException                  | 普通   | 读取一个(如果读到最后，返回-1) |
|  2 | public int read(byte[] b) throws IOException                   | *重要* | 读取一组(返回实际)             |
|  3 | public int read(byte[] b, int off, int len) throws IOException |        | 读取部分                       |
*** Writer
* 正则表达式
* 对象引用分析
所谓的引用数据类型，就是同一块 *堆内存* 空间，可以被不同的 *栈内存* 指向。
垃圾空间：就是没有任何栈内存的指向的堆内存，所有的垃圾空间都会被 *GC* 不定期回收。
类对象的属性封装：就是用 ~private~ 修饰变量（属性），这样外部无法直接使用该变量。
#+begin_src java
public class Person {
    private String name;
    private byte age;
    public Person(String name, byte age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return "Name is " + this.name + " and age is " + this.age;
    }
}
public class Basic {
    public static void main(String[] args) {
        System.out.println("类的基本使用");
        Person person = new Person("zgl", (byte) 12);
        System.out.println(person.toString());
        System.out.println(person);
    }
}

#+end_src
这样的话， ~person.name or person.age~ 是不允许的。定义 ~setterxxx()~ 和 ~getterxxx()~ 函数
** 构造方法和匿名对象
Java 在创建对象的时候，如果总是用 ~setXXX()~ 函数，那么比较的繁琐，所以 Java 提供了构造方法。
1. 构造方法的名称必须和类名称一致。
2. 构造方法没有返回值的定义。
3. 构造方法是在使用关键字 ~new~ 创建实例化对象的时候自动调用（重要）。
4. 每个类至少有一个无参的构造函数。
5. *构造函数同样支持重载*
#+begin_src java
// 假如有了一个 Person 类
// 构造方法如下
public Person(String name, int age){
    this.name = name;
    this.age = age;
}
#+end_src
~public void Persion(String name, int age)~ 是错误的， *程序编译器根据代码结构进行编译处理的，执行的时候也是根据代码结构进行处理的。*
*** 匿名对象
比较简单，没有引用，用完就是垃圾空间，例如 ~new Person().tell()~
** this 关键字
~this~ 关键字在 Java 类中比较的好用，在以后的 Java 类中，调用属性和方法都用 ~this~ 修饰。
#+begin_src java
package work.sayno.www;

public class Person {
    private String name;
    private byte age;
    public Person(){
        System.out.println("开始实例化");
    }
    public Person(String name){
        this();
        this.setName(name);
    }
    public Person(String name, byte age){
        this(name);
        this.setAge(age);
    }
    public byte getAge() {
        return age;
    }
    public void setAge(byte age) {
        if (age < 0){
            System.out.println("\033[31mPlease input the correct age.\nNow, I will set age to 0.\033[0m");
            this.age = 0;
            return;
        }
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String toString(){
        return "Name is " + this.name + " and age is " + this.age;
    }
}
#+end_src
对与 =this= 的使用，构造函数的嵌套使用，详情见如上代码。
*this() 必须放在构造函数的首行*
** 简单 Java 类
1. 类的名称必须有意义。
2. 类之中的所有属性必须使用 ~private~ 进行修饰，并且提供 =setXX= 和 =getXX= 方法。
3. 类之中可以提供无数个构造方法，但是必须保留一个无参的构造方法。
4. 类之中不允许出现任何的输出语句，所有的内容必须直接返回。
5. （可选）提供一个获取详细信息的的方法。
** static 关键字
在 Java 中 ~static~ 是一个非常常见的关键字，用来修饰属性和方法。
*** Preface
在一个类中，所有的属性一旦定义，内容都是交给堆内存保存。
*** static 属性
使用 ~static~ 声明的属性是全局的，所有的对象都是共用一个变量。一旦变化就是全部变化。 ~static~ 属性访问用最高权限来访问，就是类本身。
1. 大部分的情况下，非 ~static~ 的属性是首选的，除非是公共的信息存储。
2. ~static~ 属性可以在没有实例化的情况下使用，非 ~static~ 属性不能够。
*** static 方法
~static~ 定义的方法主要特点是：可以直接由类名称直接调用，不需要进行实例化对象。
1. ~static~ 方法： ~static~ 方法只允许调用 ~static~ 属性和 ~static~ 方法。
2. 非 ~static~ 方法：允许调用 ~static~ 属性和 ~static~ 方法。
3. ~static~ 方法中调用 ~private~ 属性不需要使用 ~this~ ，因为本来就不要实例化就可以使用（都不需要使用）。
4. ~static~ 的方法或者属性大致上用的还是比较少的。
*** static 案例
自动统计创建了多少个实例化对象;
#+begin_src java
package work.sayno.www;

public class Count {
    private static int count = 0;
    public Count(){
        count++;
    }
    public String toString(){
        return Integer.toString(count);
    }
}
#+end_src
** 代码块
*** 普通代码块
定义在一个方法中的代码块。 由于 Java 中不允许同一个变量名重复定义，但是如果是在代码块中，那就是有了作用域。
#+begin_src java
public void print(){
    if(true){
        int x=0;
        System.out.println(x);
    }
    int x = 100;
    System.out.println(x);
}
#+end_src
上面的代码就是有普通代码块（还好我读过一点点的 C Prime Plus）对于这些理解还是好一点的。
*** 构造块
构造块，听名字就知道是构造时候使用的，也就是说是定义在一个类中的。
*构造块的代码会优先于构造方法中代码先执行，而且每次实例化对象都会调用一次（匿名对象同样也是）*
*** 静态块
静态代码块是用 ~static~ 定义的代码块，静态块的定义有两种情况
**** 主类中定义静态块
静态代码块优先于主方法执行。
**** 非主类中定义静态块
静态代码块会优先于构造代码块执行， *不管实例化多少个对象，都执行一次* 。
1. 多个语句需要执行，最好使用静态代码块。
*** 同步代码块
* String 字符串
1. 和 C 语言一样，字符串不好直接进行比较，使用 String 类的方法 ~strA.equal(strB)~ 。
2. 字符串常量 ~String str = "www.sayno.work"~ 是匿名的 String 类对象。
** 字符串比较
1. ~==~ 这是常见的进行是否相等的比较：对于基本的数据类型，比较的是他们的数值，对于引用数据类型，比较的是在堆内存中的地址。
2. ~equals~ 继承 =Object= 类的方法，直接进行内容的判断（以后都是使用 ~equals~ 进行字符串判断）。
** Java 中两种字符串实例化的比较
*** 匿名对象
直接将字符串赋值给一个变量。例如 ~String url="www.sayno.work"~ ，Java 底层中有一个字符串常量池（字符串数组），所以
#+begin_src java
String A="www";
String B="www";
#+end_src
A 和 B 指向的是同一块堆内存。当使用匿名对象实现字符串的时候，每次赋值的时候，如果字符串常量池有这个字符串，那么直接指向这块地址，如果没有，存放到字符串常量池，然后再指向这块地址。
*** 构造方法实例化
~String str = new String("www");~ 这样的话，会开辟两块堆内存， ~"www"~ 到常量池，然后 ~new~ 开辟一块空间，最后常量池中的成为了垃圾空间。
**** 另外一种形式
首先 ~String strA = "www";~ 接着 ~String strB = new String("www");~ 这个是自动开辟堆内存空间（ *但是常量池中有了该字符串，所以不会产生垃圾空间* ），所以地址还是不一样。但是可以通过 ~intern()~ 方法手动入池(*必须是在new String之后直接调用*)。
#+begin_src java
package work.sayno.www;

public class Basic {
    public static void main(String[] args) {
        System.out.println("字符串的基本使用");
        String strA = "www.sayno.work";
        String strB = "www.sayno.work";
        String strC = new String("www.sayno.work").intern();
        System.out.println(strA == strB);
        System.out.println(strA.hashCode());
        System.out.println(strB.hashCode());
        System.out.println(strC.hashCode());
        System.out.println(strA.equals(strC));
        System.out.println(strA == strC);
    }
}
#+end_src
*** String 类两种实例化方式的区别
1. 直接赋值：只会产生一个实例化对象，并且可以保存到常量池中，实现重用；
2. 构造方法：会产生两个实例化对象，不会自动保存到常量池，无法重用，可以在构造的使用使用 ~intern()~ 方法手动入池。
** 字符串常量池

* 数组
开发中通常不会使用这个。
1. Java 中数组是引用数据类型。
#+begin_src java
1. 动态初始化： 数据类型 [] 数组名称 = new 数据类型[长度];
2. 静态初始化（在数组定义的时候就设置里面的内容）  数据类型 [] 数组名称 = new 数据类型[] {第一个，第二个，....};
#+end_src
2. Java 中的数组操作和其他语言没有其他的区别。
   1. ~array.length~ 返回数组的长度
   2. 动态初始化每个变量都是 *数据类型* 的默认值。
3. Java 中的 ~for each~ 循环，自动获取数组的每一个元素
#+begin_src java
foreach(int a: array){
    System.out.println(a);
}
#+end_src
循环将 array 数组中的变量赋值给变量 a。
** 二维数组
一些关于二维数组的操作，一般来说，二维数组很少用得到。
#+begin_src java
System.out.println("二位数组的定义和使用");
System.out.println("动态二维数组的定义和使用");
Integer [][] tArray = new Integer[2][3];
for (Integer []hang :
        tArray) {
    for (Integer item :
            hang) {
        System.out.println(item);
    }
}
System.out.println("静态二维数组的的的定义和输出");
Integer [][] jtArray = new Integer[][] {{1,2,3}, {3,4}};
for(Integer[] hang: jtArray){
    for(Integer item: hang){
        System.out.println(item);
    }
}
#+end_src

** 数组的方法
Java 语言本身提供了数组相关支持的处理。 ~java.util.Arrays.*~ 提供了相关的操作。
1. ~sort()~
2. ~arraycopy()~
** 方法的可变参数
Java 中方法接收可变参数的实现。（可变参数的本质还是数组，只是去掉了外壳）
#+begin_src java
public static int sum(int ... data){
    int sum=0;
    for(int item :data){
        sum += item;
    }
    return sum;
}
#+end_src

** 类数组
类数组和普通的数组没有其他的操作区别。
** 类关联结构
其他类之间进行关联操作
#+begin_src java
package work.sayno.www;

public class Union {
    public static void main(String[] args) {
        System.out.println("类关联结构");
        Person zgl = new Person("周国良", 20);
        System.out.println("生成汽车");
        Car bwm = new Car("宝马", 200000);
        System.out.println(zgl.getCar());
        System.out.println("绑定汽车");
        zgl.setCar(bwm);
        System.out.println(zgl.getCar());
    }
}
package work.sayno.www;

public class Car {
    private String name;
    private double price;
    public Car(){}
    public Car(String name, double price){
        this.setName(name);
        this.setPrice(price);
    }

    public String toString(){
        return "车名：" + this.name + "；车的价值：" + this.price;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
package work.sayno.www;

public class Person {
    private String name;
    private int age;
    private Car car;
    public Person(){}
    public Person(String name, int age){
        this.setName(name);
        this.setAge(age);
    }
    public Person(String name, int age, Car car){
        this.setName(name);
        this.setAge(age);
        this.setCar(car);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }
}
#+end_src
** 自身关联
自身关联的代码
#+begin_src java
package work.sayno.www;

public class Union {
    public static void main(String[] args) {
        System.out.println("类关联结构");
        Person zgl = new Person("周国良", 20);
        System.out.println("生成汽车");
        Car bwm = new Car("宝马", 200000);
        System.out.println(zgl.getCar());
        System.out.println("绑定汽车");
        zgl.setCar(bwm);
        System.out.println(zgl.getCar());
        System.out.println("连接好兄弟");
        Person zt = new Person("周通", 21);
        System.out.println("兄弟买车");
        Car kln = new Car("库里南", 1000000);
        zt.setCar(kln);
        System.out.println("连接好兄弟");
        System.out.println(zgl.getBrother());
        zgl.setBrother(zt);
        System.out.println(zgl.getBrother());

        Person zy = new Person("周x", 21);
        System.out.println("兄弟买车");
        Car kln2 = new Car("库里南2", 1000000);
        zy.setCar(kln2);
        zgl.setBrother(zy);
        for(Person temp: zgl.getBrother()){
            System.out.println(temp.getCar());
        }
    }
}
package work.sayno.www;

public class Car {
    private String name;
    private double price;
    public Car(){}
    public Car(String name, double price){
        this.setName(name);
        this.setPrice(price);
    }

    public String toString(){
        return "车名：" + this.name + "；车的价值：" + this.price;
    }
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getPrice() {
        return price;
    }

    public void setPrice(double price) {
        this.price = price;
    }
}
package work.sayno.www;

import java.util.ArrayList;

public class Person {
    private String name;
    private int age;
    private Car car;
    private ArrayList<Person> brother = new ArrayList<Person>();
    public Person(){}
    public Person(String name, int age){
        this.setName(name);
        this.setAge(age);
    }
    public Person(String name, int age, Car car){
        this.setName(name);
        this.setAge(age);
        this.setCar(car);
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Car getCar() {
        return car;
    }

    public void setCar(Car car) {
        this.car = car;
    }

    public ArrayList<Person> getBrother() {
        return brother;
    }

    public void setBrother(Person person) {
        this.brother.add(person);
    }

    public String toString(){
        ArrayList<Person> temp = this.getBrother();
        StringBuffer brother_name = new StringBuffer();
        for (Person item:temp){
            brother_name.append(item.getName()).append("、");
        }
        return "名字：" + this.getName() + " 年龄：" + this.getAge() + " 汽车" + this.getCar() +
        " 兄弟：" + brother_name;
    }
}

#+end_src
** 合成设计
像一台电脑可以拆分为 CPU 主机 显示器等，这就是合成设计。

* 泛型
主要用于结果多数据类型的问题，
#+begin_src java
public class Point {
    private Object x;
    private Object y;
    public Point(){}
    public Point(Object x, Object y){
        this.setX(x);
        this.setY(y);
    }
}
#+end_src
如果像上面一样定义那么，可以会出现数据类型混乱，如
#+begin_src java
public class Basic {
    public static void main(String[] args) {
        System.out.println("泛型的学习");
        Point t = new Point(1, 2);
        System.out.println(t);
        Point t2 = new Point(1.2, 4.5);
        System.out.println(t2);
        Point t3 = new Point("东经112", "北纬20");
        System.out.println(t3);
        Point t4 = new Point(1, "北纬23");
        System.out.println(t4);
    }
}
#+end_src
泛型的诞生就是没了减少这种问题的产生。
** 泛型的本质
类中的属性或者方法的相应的数据类型可以由实例化的时候来决定，在类定义的时候明确定义占位符（泛型标记）。
** 基本使用
*类或者接口追加了泛型之后，如果不设置泛型类型的时候，会自动使用 Object 类型，在编译的时候会报错* 。
#+begin_src java
class ReallyPoint <T>{
    private T x;
    private T y;
    public ReallyPoint(){}
    public ReallyPoint(T x, T y){
        this.setX(x);
        this.setY(y);
    }

    public T getX() {
        return x;
    }

    public void setX(T x) {
        this.x = x;
    }

    public T getY() {
        return y;
    }

    public void setY(T y) {
        this.y = y;
    }

    @Override
    public String toString() {
        return "ReallyPoint{" +
                "x=" + x +
                ", y=" + y +
                '}';
    }
}
public class Basic {
    public static void main(String[] args) {
        System.out.println("使用泛型");
        ReallyPoint<Integer> reallyPoint1 = new ReallyPoint<Integer>(1, 2);
        ReallyPoint<String> reallyPoint2 = new ReallyPoint<String>("北纬20", "东经120");
        System.out.println(reallyPoint1);
        System.out.println(reallyPoint2);
    }
}

#+end_src

#+RESULTS:
: 使用泛型
: ReallyPoint{x=1, y=2}
: ReallyPoint{x=北纬20, y=东经120}
** 泛型使用注意点
1. 泛型之中之允许设置引用类型，如果要使用基本数据类型，那就使用包装类
2. 后面的泛型可以省略 ~ReallyPoint<Integer> reallyPoint1 = new ReallyPoint<Integer>(1, 2);~ 可以简化为 ~ReallyPoint<Integer> reallyPoint1 = new ReallyPoint<>(1, 2);~

** 泛型通配符
当一个方法接受使用泛型的类的时候，不能确定该类泛型的具体类型，例如
#+begin_src java
class Message<T>{}
public static void accept(Message<> msg)
#+end_src
此时 accept 方法不知道接受的 Message 类的类型， ~Message<String> or Message<Integer>~ 都可能作为参数传递，所以这个时候 *泛型通配符* 的作用就出来了， ~?~ 就是泛型通配符
#+begin_src java
public static void accept(Message<?> msg)
#+end_src
此时的 accept 方法可以接受所有的泛型类型，而且，此时最重要的是，由于使用的是 ~?~ 通配符，不清楚具体类型，无法修改类对象中的数据
** 通配符和泛型设置上下限
1. ~<? extends 类>~ 设置泛型的上限
#+begin_src java
class Message<T extends Number>
// 那么Message 只能是 Number 或者 Number 类的子类
#+end_src
2. ~<? super 类>~ 设置泛型的下限
#+begin_src java
class Message<T super String>
// 那么 Message 只能 String 以及 String 的父类
#+end_src
所以说要多看 Java Doc 来了解类之间的继承关系。
** 泛型接口
如果一个接口设置了泛型，例如
#+begin_src java
interface IMessage<T>{...}
#+end_src
那么继承或者实现该接口的子类或者接口（接口的可以多继承接口）有 *两种方式实现泛型*
1. 继续设置泛型
#+begin_src java
class Message<S> implements IMessage<S>{...}
#+end_src
2. 直接实现泛型
#+begin_src java
class Message implements IMessage<String>{...}
// 实例化对象
Message<String> msg = new Message<>();
#+end_src
* Java 类集
Java 从 JDK1.2 开始引入了类集开发框架，所谓的 *类集* 就是一套动态数组的实现方案，在实际的开发中，数组是必须的，但是传统的数组实现非常繁琐，而且由于长度问题，导致操作是比较麻烦的，依靠数据结构来实现动态数组，其中较为重要的是 1. 链表 2. 树
1. 数据结构的代码实现困难，对于一般的开发者是无法进行使用的。
2. 对于链表或者树更新维护比较麻烦。
3. 性能可能存在问题。
基于以上原因，类集应景而生。
** 核心接口
1. Collection
2. List
3. Set
4. Map
5. Iterator
6. Enumeration
7. Queue
8. ListIterator
** Collection 接口
~java.util.Collection~ 是单值集合操作的最大父接口，该接口中定义了所有的单值集合操作方法。
** List 接口
List 是 Collection 的子接口。有了更多的操作方法，但是由于还是一个接口，所以还是需要使用子类来使用，下面是是那个常用的子类
1. ArrayList
2. Vector
3. LinkedList
*** ArrayList 类
~ArrayList~ 是 List 使用最多的子类，

* Java 注解(Annotation)
Annotation 是从 JDK1.5 之后提出的新的技术结构，可以有效的减少的程序配置的代码，还可以进行一些结构化定义，Annotation 是以一种注解的形式实现程序的开发。
程序开发的过程
1. 程序相关的的所有数据都写入到程序代码之中，这样在后期的维护和更改不会方便。
2. 引入配置文件，在配置文件中定义全部要使用的服务器资源。（1. 在配置文件不多的时候，这样的配置非常简单，但是当配置文件过多的时候，开发也会变得困难。 2. 所有的操作都要配置文件完成，对于开发不是那么的方便
3. 将配置文件重新写入到程序里面，通过一些特殊的标注和程序代码进行分离，这就是注解（Annotation）。
   1. 实际上，全部使用注解开发难度还是高，所以现在基本上是 Annotation 和配置文件一起使用。
** 常见的注解
1. ~@Override~ 当使用继承的时候，如果忘记书写 ~extends~ ，或者方法名字写错。在覆写的方法上加上 ~@Override~ 会给你相关信息。（主要是在开发的时候提供相关报错
2. ~@Deprecated~ 过期声明
3. ~@SuppressWarnings~ 压制警告，让警告信息不出现 ~@SuppressWarnings({"deprecation"})~ 压制过期警告。
* 面向对象三大特性
** 封装性
类对象的属性封装：就是用 ~private~ 修饰变量（属性），这样外部无法直接使用该变量。
#+begin_src java
public class Person {
    private String name;
    private byte age;
    public Person(String name, byte age){
        this.name = name;
        this.age = age;
    }
    public String toString(){
        return "Name is " + this.name + " and age is " + this.age;
    }
}
public class Basic {
    public static void main(String[] args) {
        System.out.println("类的基本使用");
        Person person = new Person("zgl", (byte) 12);
        System.out.println(person.toString());
        System.out.println(person);
    }
}

#+end_src
这样的话， ~person.name or person.age~ 是不允许的。定义 ~setterxxx()~ 和 ~getterxxx()~ 函数

** 继承性
** 多态性
多态性是在继承性的基础上扩展来，可以实现父子类之间的互相转换处理（向上或者向下转型
*** 基本概念
1. 方法的多态性
    1. 方法的重载：同一个方法名称可一根据传入的参数的类型过着个数的不同实现不同的功能。
    #+begin_src java
public class Basic {
    public static void main(String[] args) {
        print();
        print("大帅哥");
    }
    public static void print(){
        System.out.println("Hello, IDEA");
    }
    public static void print(String  name){
        System.out.println("Hello, " + name);
    }
}
    #+end_src

    #+RESULTS:
    : Hello, IDEA
    : Hello, 大帅哥
    2. 方法的覆写：根据子类的不同，方法实现的方式不同
2. 对象的多态性：父子实例之间的转换处理
    1. 对象向上转型：父类 父类实例 = 子类实例；自动完成转换(人是动物)
    2. 对象向下转型：子类 子类实例 = （子类）父类实例；强制完成
在实际情况下， 基本上是使用向上转型， *对于对象的向下转型往往都在使用子类的特殊功能* 。
*** 对象向上转型(接收或者返回的统一性)
#+begin_src java
public class Basic {
    public static void main(String[] args) {
        System.out.println("对象的多态性");
        Channel channel = new NetChannel(); // 对象的向上转型
        fun(new NetChannel());
        fun(new Channel());
        fun(new WebChannel());
    }
    public static void fun(Channel channel){
        channel.print();
    }
}
@Override
public class WebChannel extends Channel{
    public void print(){
        System.out.println("服务器通道");
    }
}
@Override
public class NetChannel extends  Channel{
    public void print(){
        System.out.println("子类通道");
    }
}
#+end_src
使用向上转型，可以用一个参数来接收多种类型的参数。这就是向上转型的有限， *可以对参数进行统一的设计* ，这样比重载方便多了，还有利于代码后期的维护。
*** 对象向下转型
必须本身是才能够进行转型。
*** instanceof 关键字
向下转型本身是一件存在有安全隐患，所以为了保证向下转型的正确性，在进行转型之前，判断某个实例是否是某个类的对象，这就是关键字 ~instanceof~ 关键字的作用。
基本语法
#+begin_src java
对象 instanceof 类
#+end_src
返回一个 ~boolean~ 类型。 *在以后的开发中，进行向下转型之前，可以进行一次判断，再进行向下转型。*
* 抽象类
在学习 OOP 三大特性之一的继承性质的时候，子类可以选择是否覆写父类的方法，父类无法对子类进行强制约定，如果需要强制覆写，可以使用抽象类，在实际上，很少出现继承一个完善的类。父类基本上是优先考虑使用抽象类
** 定义
抽象类的主要作用是在于对子类中覆写方法进行约定，在抽象类可以去定义一些抽象方法来实现这个约定，抽象方法是使用了 ~abstract~ 关键字的并且不需要提供方法体，而抽象方法必须放在抽象类中（用 ~abstarct~ 修饰的类。
本质上，抽象类就是在普通类中在满足抽象类的条件下添加了一些抽象方法。 *抽象类无法直接实例化* ，抽象类不是完整的，想用抽象类的原则
1. 抽象类必须要有子类
2. 抽象类的子类不能是抽象类，而且要覆写所有的抽象方法。
3. 抽象类的对象实例化可以利用对象多态性通过子类向上转型完成。
#+begin_src java
public class AbstractUsage {
    public static void main(String[] args) {
        System.out.println("抽象类的学习");
        Message message = new MySQLMessage();
        message.setType("周国良");
        System.out.println(message.getConnectInfo());
    }
}
public class MySQLMessage extends Message{
    @Override
    public String getConnectInfo() {
        return this.getType() + this.getClass();
    }
}
public abstract class Message {
    private String type;
    public abstract String getConnectInfo();
    public void setType(String type){
        this.type = type;
    }
    public String getType(){
        return this.type;
    }
}
#+end_src

#+RESULTS:

抽象类除了要求子类必须覆写抽象方法，其余和普通类没有什么区别。
抽象类使用几点意见
1. 抽象类无法直接实例化
2. 抽象类之中主要目的是进行过度操作使用，所以当使用抽象类进行开发的时候，往往是在设计中要解决类继承问题代码重复问题。
** 使用说明
1. 抽象类由于是设计为子类继承使用，所以无法使用 ~final~ 关键字。
2. 抽象类作为普通类的加强版本出现，（抽象类的组成就是在普通类的基础上扩展来的），像普通类中有属性和方法，所以抽象类还是可以有 *构造方法* ，子类会按照子类对象的实例化原则进行构造调用。
#+begin_src java
public class MySQLMessage extends Message{
    public MySQLMessage(String str){
        super(str);
    }
    @Override
    public String getConnectInfo() {
        return this.getType() + this.getClass();
    }
}
public abstract class Message {
    private String type;
    public Message(String type){
        this.setType(type);
    }
    public abstract String getConnectInfo();
    public void setType(String type){
        this.type = type;
    }
    public String getType(){
        return this.type;
    }
}
#+end_src
3. 抽象类可以没有抽象方法，但是还是无法直接实例化。
4. 抽象类可以定义 ~static~ 方法，而且不受到 ~abstract~ 限制。 *static 方法永远不受到实例化对象或者结构的限制*
** 模板设计模式
设计三类事物
1. 机器人：不休息，只要补充能量和努力工作。
2. 人：需要休息、需要吃饭以及努力的工作。
3. 猪：需要休息、要吃饭、不工作
#+begin_src java
public class Main {
    public static void main(String[] args) {
        System.out.println("设计模板");
        Up reboot = new Reboot();
        reboot.command(Up.EAT);
        Up man = new Man();
        System.out.println("人的操作");
        man.command(Up.SLEEP);
        Up pig = new Pig();
        System.out.println("猪的操作");
        pig.command(Up.WORK);
    }
}

public abstract class Up {
    public static final int EAT = 1;
    public static final int SLEEP = 5;
    public static final int WORK = 10;
    public void command(int code){
        switch (code){
            case EAT:
                this.eat();
                break;
            case SLEEP:
                this.sleep();
                break;
            case WORK:
                this.work();
                break;
            case EAT + SLEEP + WORK:{
                this.eat();
                this.work();
                this.sleep();
            }
        }
    }
    public abstract void eat();
    public abstract void sleep();
    public abstract void work();
}
public class Man extends Up{

    @Override
    public void eat() {
        System.out.println("吃饭");
    }

    @Override
    public void sleep() {
        System.out.println("睡床上");
    }

    @Override
    public void work() {
        System.out.println("一天工作 8 个小时");
    }
}
public class Pig extends Up{

    @Override
    public void eat() {
        System.out.println("啥都吃");
    }

    @Override
    public void sleep() {
        System.out.println("睡猪圈");
    }

    @Override
    public void work() {
        System.out.println("打工，这辈子不可能打工的");
    }
}
#+end_src
不过抽象类还是难的，对着写了一遍，我还是没理解这个作用。

* 包装类
包装类的主要功能是针对与 *基本数据* 类型的对象转换而实现的
** 基本定义
Object 类最大的特点就是所有类的父类，可以接收所有的数据类型，但是基本数据类型不是类，在 ~泛型~ 里面只能是引用数据类型，基本数据类型无法使用，所以这个时候需要的是将基本数据类以类的形式作为处理，这就是所谓的 *包装类* 。基本数据类型进行包装类型之后，可以像对象一样进行引用传递。
1. 装箱：将基本数据类型保存在包装类之中。
2. 拆箱：从包装类对象中获取基本数据类型。
基本数据类型的 *装箱* ：
| 基本数据类型 | 包装类    |
|--------------+-----------|
| int          | Integer   |
| char         | Character |
| byte         | Byte      |
| double       | Double    |
| short        | Short     |
| long         | Long      |
| float        | Float     |
| boolean      | Boolean   |
** 说明
在 Java 中包装类提供两种类型
1. 对象型包装类：（Object 直接子类）：Boolean、Character
2. 数值型包装类：（Number(abstarct) 子类）：Byte、Short、Integer、Long、Float、Double.(Number 是 Object 子类)；

** 装箱与拆箱
基本数据类型的装箱就是为了基本数据类型转化为对象的操作，衍生了基本数据类型和包装类之间有了关系
*** 数据装箱
一般可以使用构造方法，但是现在已经废弃（Java 9）
*** 数据拆箱
从包装类中获取基本数据类型
1. Number 数值型包装类提供了拆箱的方法（ ~.xxxValue()~ ）
2. Boolean 型包装类提供了 ~booleanValue()~
从 JDK 1.9 之后，包装类的构造方法基本上被舍弃了，从 JDK 1.5 之后提供了自动装箱和拆箱。也就是说可以直接使用包装类定义
#+begin_src java
Integer intValue = 10;
System.out.println(intValue++);
#+end_src
使用自动装箱最大的好处就是可以实现 Object 接收基本数据类型的操作。
#+begin_src java
Object obj = 19.2;
// 自动装箱为 Double 包装类
// 但是还有手动向下转型
double num = (Double) obj;
#+end_src
*** 包装类相关注意事项
1. 包装类的进行比较的时候，一定要使用 ~equals()~ 完成！

* 接口
接口可以理解为一个纯粹的抽象类（最原始的定义之中只有抽象方法和全局变量），但是从 JDK1.8 之后，由于引入了 ~Lambda~ 函数式编程，添加了 *普通方法和静态方法* ，从设计角度来讲，接口的组成一抽象方法和全局常量为主。
*

* JDBC usage
JDBC 的相关使用方法
1. 准备四大参数
   #+begin_src java
String driverClassName = "com.mysql.cj.jdbc.Driver";
// jdbc 协议的格式 jdbc:厂商（mysql):子协议/数据库名称
String url = "jdbc:mysql://localhost:3306/test";
String user = "sayno";
String password = "123456";
   #+end_src
2. 加载驱动
   #+begin_src java
Class.forName(driverClassName);

   #+end_src
3. 得到 Connection
#+begin_src java
Connection connection = DriverManager.getConnection(url, user, password);
#+end_src
4. 然后就是对于数据库进行增删改查（这也是对于数据库最常见的也是最基本的操作）
5. 得到 Statement （向数据库传递消息的 DML DDL）
#+begin_src java
Statement stment = connection.createStatement();
#+end_src
** Basic
*** Connection
*** Statement
1. int executeUpdate() 执行 增、删、改
2. int executeQuery() 执行查询语句，返回结果是 ResultSet;
3. boolean execute() 执行 DML 和 DDL 语句，不是那么的常用。
*** ResultSet
ResultSet 表示的是结果集合，表示的是一个数据二维表格，结果集有三个特征（使用 ~connection.createStatement()~ 确定结果集的特征
1. 是否可滚动
2. 是否敏感
3. 是否可更新
4. ~connection.createStatement()~ 的两个参数（都是 int 数据类型
#+begin_src java
// 第一个参数
ResultSet.TYPE_FORWORD_ONLY 不滚动结果集
ResultSet.TYPE_SCROLL_INSENSITIVE 滚动结果集，及时更新的数据不能立马显示
ResultSet.TYPE_SCROLL_SENSITIVE 滚动结果集，及时更新的数据能够立马显示（没有数据库驱动进行支持
// 第二个参数
CONCUR_READ_ONLY: 结果集只是可读，不能通过修改结果集影响数据库。
CONCUR_UPDATABLE: 结果集是可以更新的，对结果集的更新可以影响数据库。
// 一般来说都是 不滚动，不影响数据库
#+end_src
MySQL 默认创建的是 *可滚动* 结果集。
**** 常用的 API
1. beforeFirst() 移动到最开始的位置
2. afterLast() 移动到最后
*** 预处理
说实话，我已经快忘了 MySQL 的预处理了，
**** prepareStatement
1. 是 Statement 接口的子接口
2. 可以防止 SQL 攻击（看了一下 SQL 攻击的原理，发现这个东西好像很有意思 [[https://zh.wikipedia.org/wiki/SQL%E6%B3%A8%E5%85%A5][SQL attack]].
3. 提高效率（重复利用
**** 利用方法
1. 按照 MySQL 的预处理方法，参数使用 ~?~ 代替
2. 使用 Connection 对象的 ~prepareStatement()~ 方法
3. 使用模板方法为问号 ~?~ 进行赋值
4. 调用 executeQuery() 或者 executeUpdate() 来获取结果。
#+begin_src java
public static boolean login2(String name, String money){
    Connection connection = null;
    Statement statement = null;
    ResultSet set = null;
    try{
        String driverClassName = "com.mysql.cj.jdbc.Driver";
        String url = "jdbc:mysql://localhost:3306/test";
        String user = "sayno";
        String password = "123456";
        connection = DriverManager.getConnection(url, user, password);
        String query = "select * from accout where id=? and money=?";
        PreparedStatement preparedStatement = connection.prepareStatement(query);
        preparedStatement.setString(1, name);
        preparedStatement.setString(2, money);
        if (set == null){
            return false;
        }
        return set.next();
    }
    catch (Exception e) {
        System.out.println(e.getMessage());
        return false;
    }finally {
        try {
            if (set != null) set.close();
            if (statement != null) statement.close();
            if (connection != null) connection.close();
        }
        catch (Exception e){
            System.out.println(e.getMessage());
        }
    }
}
#+end_src
**** 预处理的原理
1. 检验 sql 的语法
2. 编译：一个与函数相似的东西
3. 执行：调用函数
***** 优点
1. 前提：连接的数据库必须支持预处理（目前来说基本都支持，但是 MySQL 中是默认的开启，需要手动开启
2. 每个预处理语句就是和 sql 模板进行绑定，数据库先进行校验和编译，执行的时候只是传递参数给 ~?~
3. 第二次执行的时候，不需要进行校验和编译的操作， *直接进行执行的操作*。
** 查询操作
#+begin_src java
ResultSet set = statement.executeQuery(String select_yuju);
// set.next() 光标向下移动一行

while(set.next()){
    // 相关操作
    set.getInt(int value) // 获取第 i 列的元素
    // 常用的就是
        // 1. getString() 2. getInt()
}
#+end_src
** 关闭资源
先得到的资源先关闭
1. set.close();
2. statement.close();
3. connection.close();
** JDBC 的代码规范
1. 在 try 外进行引用的定义 （四大件
2. 在 try 内进行对象实例化 （Connection、Statement、ResultSet
3. 在 finally 中进行资源的关闭
   #+begin_src java
    public static void query() throws Exception{
        String driverClassName = "com.mysql.cj.jdbc.Driver";
        String url = "jdbc:mysql://localhost:3306/test";
        String user = "sayno";
        String password = "123456";
        Connection connection = null;
        Statement statement = null;
        ResultSet set = null;
        try{
            Class.forName(driverClassName);
            connection = DriverManager.getConnection(url, user, password);
            statement = connection.createStatement();
            String select_str = "select * from accout";
            set = statement.executeQuery(select_str);

            while (set.next()){
                System.out.println("编号：" + set.getString("id") + "余额：" + set.getDouble("money"));
            }
        }
        catch (Exception e){
            System.out.println(e.getMessage());
        }
        finally {
            if (set != null){
                set.close();
            }
            if (statement != null){
                statement.close();
            }
            if (connection != null){
                connection.close();
            }
        }
    }
   #+end_src

** 数据库的事务（ACID
1. 原子性(atomicity)
事务中的所有 SQL 操作都是不可以再分割的原子单位，要么全部成功，要么全部失败
2. 一致性(consistency)
最重要的特性，事务执行之后，数据库状态和其他业务规则一致（转帐前后账户余额之和不会变化
3. 隔离性(isolation)
事务并发操作的时候，不同的事务应该隔离开来，使并发执行的事务不会互相干扰
4. 持久性(durablity)
一旦事务提交成功，事务中的所有的数据操作必须被持久化到数据库当中，即使数据库崩溃，也能保证通过某种机制进行数据的恢复。
** MySQL 开启事务
在 MySQL 中，每执行一次 SQL 语句，都是一个单独的事务，如果要在一个事务中开启多个事务，那么需要手动开启事务和手动结束事务
1. start transcation(begin)
2. commit(提交) 或者 rollback(回滚)
** JDBC 中开启事务
JDBC 中的开启事务的方法还是比较简单的，针对 Connection 对象进行操作。
1. ~setAutoCommit(boolean t)~ 设置为是否自动提交事务
2. ~commit()~ 提交事务
3. ~rollback()~ 回滚事务
#+begin_src java
try{
    connection.setAutoCommit(false);
    // 相关操作
    connection.commit();
}catch(Exception e){
    connection.rollback();
}
#+end_src
4. *当事务开启之后，没有手动提交或者回滚，则会自动进行回滚。*

* Java 内部类
Java 的内部类还是一个完善的类结构（在一个类的内部继续使用 ~class~ 定义一个类）
#+begin_src java
package work.sayno.www;

public class Anonymous {
    private String msg = "www.sayno.work";
    public void fun(){
        Inner inner = new Inner();
        inner.print();
    }
    class Inner{
        public void print(){
            System.out.println("这是一个内部类");
            System.out.println(Anonymous.this.msg);
        }
    }
}
Anonymous anonymous = new Anonymous();
anonymous.fun();
#+end_src
从代码结构上来看，内部类破坏了代码整体性质， 但是也有优势， *轻松的访问外部类的私有属性*
** 内部类的相关说明
在内部类中，可以通过实例化对象直接调用私有属性，不需要那些 setter 和 getter 方法进行调用（这也是最大的优势）
1. 定义内部类的对象的格式比较的特殊，
#+begin_src java
外部类.内部类 内部类对象 = new 外部类().new 内部类()
#+end_src
2. 如果定义了内部类，那么使用 javac 进行编译的时候，会产生一个 ~Outer$Innter.class~ ，就是 ~Outer.Inner~ 的意思， *定义内部类的需要先实例化外部类的原因是：他们可以进行私有属性的相互访问，如果内部类需要访问外部类的的私有属性，而外部类没有实例化对象就会出现错误*
3. 可以直接使用 ~private~ 定义私有内部类，那么就不需要顾及在外面实例化内部类的方法， 因为没了！
4. 抽象类或者接口之中都可以定义内部结构（类或者接口
5. 内部类学烦了，不学了。
* Java 链表
数组长度固定，不太方便使用，所以链表以及后面的类集产生，传统数组使用索引，不太方便进行动态管理

* Java 枚举
很多的变成语言都有枚举的概念，Java 是在 JDK1.5 之后才提出了枚举的概念，主要作用是用于定义有限个数对象的一种结构（多例设计），枚举就属于多例设计，
** 定义
* Java 反射机制
在 Java 中，之所以有如此多的开源技术支撑，很大的原因的 Java 的最大特征，反射机制，这个在日后项目的开发中非常的重要。 *所有的技术实现的目标只有一个：重用性。*
对于 *反射技术* ，首先考虑“正”和“反”， *所谓“正”的操作，就是使用类的时候，先导入程序所在的包，人，然后进行实例化，然后调用方法。“反”就是根据实例化对象反推出类型。*
#+begin_src java
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        Date date = new Date();
        System.out.println(date.getClass());
    }
}
#+end_src
上述就是通过实例化对象获取对象所属类型（说到底就是 ~getClass()~ 方法。
** Java 反射编程
Class 类的实例化操作，反射之中的所有核心操作都是通过 Class 类进行操作，有如下三种方式完成 Class 类的实例化，从 JDK1.5 之后加入了泛型的操作，（ *这三种方式都是需要掌握的*
#+begin_src java
public final class Class<T>
extends Object
implements Serializable, GenericDeclaration, Type, AnnotatedElement, TypeDescriptor.OfField<Class<?>>, Constable
#+end_src
*** 通过 Object 类支持
Object 类可以通过实例化对象获得 Class， ~public final Class<?> getClass()~
#+begin_src java
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        Date date = new Date();
        Class<? extends Date> cls = date.getClass();
        System.out.println(cls);
        System.out.println(cls.getName());
    }
}
#+end_src

#+RESULTS:
: class java.util.Date
: java.util.Date

这个方式有个不是缺点的缺点，如果想要 Class，那么必须实例化对象。
*** JVM 原生支持
~类.class~ ：必须导入程序相应的包
#+begin_src java
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        Class<? extends Date> cls2 = Date.class;
        System.out.println(cls2);
        System.out.println(cls2.getName());
    }
}

#+end_src

*** Class 类支持
在 Class 中提供一个操作的 ~static~ 方法，当初我们学 ~JDBC~ 的时候使用过， ~Class.forName(String className)~
#+begin_src java
import java.util.Date;

public class Test {
    public static void main(String[] args) {
        Class<?> cls3 = Class.forName("com.itheima.GServlet");
        System.out.println(cls3);
        System.out.println(cls3.getName());
    }
}
#+end_src
如果此时使用程序不存在，会出现 ~java.lang.ClassNotFoundException~ 。

* Java Lambda 表达式
** 基本使用
从 JDK1.8 开始为了简化使用着进行代码的开发，专门提供了有 Lambda表达式是的支持，利用函数式的变成可以省略一部分面向对象的麻烦（Python 使用函数式变成可以代替工厂模式。
面向对象在长期发展的过程之中，有些反对者认为面向对象的设计过于复杂。
#+begin_src java
interface IPerson {
    public void send(String str);
}
public class Main {
    public static void main(String[] args) {
        System.out.println("Lambda 表达式");
        IPerson person = new IPerson() {
            @Override
            public void send(String str) {
                System.out.println("「发送消息」" + str);
            }
        };
        person.send("我好帅");
    }
}
#+end_src
如上面代码所显示一样，为了实现一行代码的输出，写了一堆，使用 Lambda 表达式来实现。
#+begin_src java
interface IPerson {
    public void send(String str);
}
public class Main {
    public static void main(String[] args) {
        System.out.println("Lambda 表达式");
        IPerson person = (str)->{
            System.out.println("「发送消息」" + str);
        };
        person.send("我好帅");
    }
}

#+end_src
实现了同样的效果，编写的代码量确少了很多。
** 使用要求
Lambda 表达式如果想要使用，那么必须有一个重要的实现要求：SAM(Single Abstarct Method)，只有一个抽象方法。在上述接口 IPerson 中，只提供了一个抽象方法 ~send()~ ，没有其他方法定义，这样的接口被称为 *函数式接口* ，只有 *函数式接口* 才能使用 Lambda 表达式。
#+begin_quote
为了明确的表示，这是函数式接口，加入 @FunctionalInterface ，表示这是一个明确的函数式接口，接口中只能有一个方法。
#+end_quote
1. *但是如果是接口中定义了 defalut 方法是不影响的* 。
2. Lambda 表达式的格式
    #+begin_src java
    // 方法没有参数： ()->{}
    // 方法有参数： (argument, argument)->{}
    // 如果只有一行语句返回： (argument, argument)-> statement
    interface IPerson {
        public void send(String str);
    }
    interface IMath {
        public int add(int x, int y);
    }
    public class Main {
        public static void main(String[] args) {
            System.out.println("Lambda 表达式");
            IPerson person = (str) -> {
                System.out.println("「发送消息」" + str);
            };
            person.send("我好帅");
            IMath iMath = Integer::sum;
            System.out.println(iMath.add(1, 2));
        }
    }
    #+end_src
3. 利用 Lambda 表达式确实比较方便的简化了代码的实现。（匿名内部类还是挺好的，在多方法的接口中无法使用 Lambda 进行描述）。

** 方法引用
引用数据类型最大的特点是可以进行内存的指向处理，在传统的开发之中一直是对象的引用操作，从 JDK1.8 之后也提供了方法的引用，方法的引用在 Java 中有四种方式。
1. 引用静态方法: ~类名称::static 方法名称~ (~System.out::println)~.
   #+begin_src java
@FunctionalInterface
interface IFunction<P, R> {
    public R change(P p);
}

public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        IFunction<Integer, String> function = String :: valueOf;
        String str = function.change(100);
        System.out.println(str.length());
    }
}
// 上述代码就是第一种方法引用，引用只有一个要求： *可以实现方法名称的定义* ，可以为一个函数定义多个名字，但是必须是函数式接口。
   #+end_src
2. 引用某个实例化对象的方法： ~实例化对象::普通方法~.
   #+begin_src java
@FunctionalInterface
interface IFunction<R> {
    public R upper();
}
public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        IFunction<String> function = "www.sayno.work" :: toUpperCase;
        String str = function.upper();
        System.out.println(str);
    }
}
   #+end_src
3. 应用特定类型的方法： ~特定类::普通方法~.
   #+begin_src java
@FunctionalInterface
interface IFunction<R> {
    public int compare(R r1, R r2);
}
public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        IFunction<String> function = String :: compareTo;
        System.out.println(function.compare("A", "a"));
    }
}
   #+end_src
4. 引用构造方法： ~类名称::new~.
   #+begin_src java
public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        IFunction<Person> iFunction = Person::new;
        Person person = iFunction.create("周国良", 20);
        System.out.println(person.getName() + person.getAge());
    }
}
@FunctionalInterface
interface IFunction<R> {
    public R create(String s, int a);
}
class Person {
    private String name;
    private int age;
    public Person(){}
    public Person(String name, int age){
        this.setName(name);
        this.setAge(age);
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

   #+end_src
5. 方法引用最大的又是只是弥补了对于引用的支持功能，传统只有对象引用。

** 内建函数式接口
自己开发函数式接口，需要大量的 ~@FunctionalInterface~ 来声明，可以使用系统的， ~java.util.function~ 直接使用函数式接口，有几个核心的函数式接口
*** 功能型函数接口
功能型函数接口的定义([[https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/Function.html][Function-doc]])，接收一个，返回一个，同类型还有很多，这个只是一个基础形式的接口，如 ~DoubleFunction<R>~ ，不过本质相同
#+begin_src java
@FunctionalInterface
public interface Function<T,R>{
    R apply(T t);
}
#+end_src
案例如下
#+begin_src java
import java.util.function.Function;

public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        Function<String, Boolean> function= "sayno.work" :: startsWith;
        System.out.println(function.apply("sayno"));
    }
}
#+end_src
*** 消费型函数接口
只能进行数据的操作，没有数据的返回
#+begin_src java
@FunctionalInterface
public interface Consumer<T>{
    void accept(T t);
}
#+end_src
案例如下
#+begin_src java
import java.util.function.Consumer;

public class Basic {
    public static void main(String[] args) {
        System.out.println("方法引用");
        Consumer<String> consumer = System.out :: println;
        consumer.accept("www.sayno.work");
    }
}
#+end_src
今天学习的时候(<2022-05-03 Tue>)，还一直在想，看完 Lambda 之后，看看啥是 Consumer 接口，因为在 List 碰到了，他的 ~forEach()~ 方法接收的就是一个 ~Consumer~ 类型的。
#+begin_src java
import java.util.ArrayList;
import java.util.List;

public class Basic {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        list.add(100);
        list.add(200);
        list.forEach(System.out::println);
    }
}

#+end_src
*** 供给型函数接口
没有数据的接收，有数据的返回
#+begin_src java
@FunctionalInterface
public interface Supplier<T>{
    T get();
}
#+end_src
案例如下
#+begin_src java
import java.util.function.Supplier;

public class Basic {
    public static void main(String[] args) {
        Supplier<String> supplier = "WWW.SAyno.Work":: toLowerCase;
        System.out.println(supplier.get());
    }
}
#+end_src
*** 断言型函数接口
进行判断处理
#+begin_src java
@FunctionalInterface
public interface Predicate<T>{
    boolean test(T t);
}
#+end_src
案例如下
#+begin_src java
package work.sayno.www;
import java.util.function.Predicate;

public class Basic {
    public static void main(String[] args) {
        Predicate<String> predicate = "SaYNo" :: equalsIgnoreCase;
        System.out.println(predicate.test("sayno"));
    }
}
#+end_src
*** 小结
在以后的开发中，如果提供的函数接口足够我们使用，没有就需要自己定义，较为的麻烦。
